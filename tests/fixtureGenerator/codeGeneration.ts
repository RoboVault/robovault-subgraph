let fs = require('fs');
let process = require('process');

export function convertFixturesToAssemblyScript(
  mockName: string,
  fixtures,
  contractCalls,
  events,
  extraVariableDecls
): string {
  let script = `
// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
import { createMockedFunction } from 'matchstick-as';
import {
  BigInt,
  ethereum,
  log,
  Address,
  Bytes,
  ByteArray,
} from '@graphprotocol/graph-ts';

export namespace ${mockName} {
`;
  for (const varName in extraVariableDecls) {
    script = script.concat(`
  export const ${varName}="${extraVariableDecls[varName]}";`);
  }

  script = script.concat(`
  export function mockChainState(): void {
  `);
  for (const i in fixtures) {
    let s = fixture2AssemblyScript(fixtures[i]);
    script = script.concat(s);
  }
  script = script.concat(`
  }
  `);

  /*
  for (const i in contractCalls) {
    let s = generateContractCallScript(i, contractCalls[i]);
    script = script.concat(s);
  }


*/
  for (const i in events) {
    throw new Error('not implemented');
  }
  for (const i in contractCalls) {
    throw new Error('not implemented');
  }

  script = script.concat(`}`);
  return script;
}

export function writeFixtureScriptFile(mockName, script) {
  fs.writeFileSync(`${process.cwd()}/tests/fixtures/${mockName}.ts`, script);
}

function valueToAssemblyscript(type, value): string {
  if (type == 'uint256') {
    return `ethereum.Value.fromUnsignedBigInt(BigInt.fromString('${value}'))`;
  } else if (type == 'string') {
    return `ethereum.Value.fromString('${value}')`;
  } else if (type == 'address') {
    return `ethereum.Value.fromAddress(Address.fromString('${value}'))`;
  } else if (type == 'uint8') {
    return `ethereum.Value.fromUnsignedBigInt(BigInt.fromString('${value}'))`;
  } else if (type == 'uint128') {
    return `ethereum.Value.fromUnsignedBigInt(BigInt.fromString('${value}'))`;
  } else if (type == 'bool') {
    return `ethereum.Value.fromBoolean(${value})`;
  } else {
    throw new Error(`No definition for type: ${type}`);
  }
}

function generateParamTypesScript(signature: string, values: [string]): string {
  let split = signature.split(':');
  let firstParen = split[0].indexOf('(');
  let paramTypes = split[0].slice(firstParen + 1, -1).split(',');
  if (paramTypes.length != values.length) {
    throw new Error(
      `Number of defined param types does not match the number of provided param values for ${signature}`
    );
  }

  let ret = '';
  for (const i in paramTypes) {
    let decl = valueToAssemblyscript(paramTypes[i], values[i]);
    let v = `
    ${decl},`;
    ret = ret.concat(v);
  }
  return ret;
}

function generateReturnTypesScript(
  signature: string,
  values: [string]
): string {
  let split = signature.split(':');
  let returnTypes = split[1].slice(1, -1).split(',');
  if (returnTypes.length != values.length) {
    throw new Error(
      `Number of defined return types does not match the number of provided return values for ${signature}`
    );
  }

  let ret = '';
  for (const i in returnTypes) {
    let decl = valueToAssemblyscript(returnTypes[i], values[i]);
    let v = `
    ${decl},`;
    ret = ret.concat(v);
  }
  return ret;
}

function generateContractCallScript(call_descriptor, call): string {
  return '';
}

function fixture2AssemblyScript(fixture): string {
  let script = '';
  for (const i in fixture.mockedFunctions) {
    let func = fixture.mockedFunctions[i];

    if ('cases' in func) {
      for (const caseIdx in func.cases) {
        let params = func.cases[caseIdx].params;
        let retValues = func.cases[caseIdx].retValue;
        let paramsGenerated = generateParamTypesScript(
          func.fnSignature,
          params
        );
        let retValuesGenerated = generateReturnTypesScript(
          func.fnSignature,
          retValues
        );
        let mockScript = null;
        if ('reverts' in func.cases[caseIdx] && func.cases[caseIdx].reverts) {
          mockScript = `
    createMockedFunction(
      Address.fromString('${fixture.contractAddress}'),
      '${func.fnName}',
      '${func.fnSignature}'
    ).withArgs([${paramsGenerated}
    ]).reverts();
        `;
        } else {
          mockScript = `
    createMockedFunction(
      Address.fromString('${fixture.contractAddress}'),
      '${func.fnName}',
      '${func.fnSignature}'
    ).withArgs([${paramsGenerated}
    ]).returns([${retValuesGenerated}
    ]);
        `;
        }
        script = script.concat(mockScript);
      }
    } else {
      let returns = generateReturnTypesScript(func.fnSignature, func.value);
      let mockScript = null;
      if ('reverts' in func && func.reverts) {
        mockScript = `
    createMockedFunction(
      Address.fromString('${fixture.contractAddress}'),
      '${func.fnName}',
      '${func.fnSignature}'
    ).reverts();

  `;
      } else {
        mockScript = `
    createMockedFunction(
      Address.fromString('${fixture.contractAddress}'),
      '${func.fnName}',
      '${func.fnSignature}'
    ).returns([${returns}
    ]);

  `;
      }
      script = script.concat(mockScript);
    }
  }
  return script;
}
